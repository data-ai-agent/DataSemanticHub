# 组织架构管理 - 后端开发需求规格说明书

## 1. 概述与目标

组织架构（Organization / Department）是系统基础数据的核心，支撑 **用户归属**、**数据权限范围**（Data Scope）以及 **审批流转**。
本模块目标是构建一个支持无限层级、高性能查询、灵活变动的组织树服务。

### 1.1 核心能力
* **CRUD与层级管理**：增删改查、拖拽排序、层级调整。
* **高性能树操作**：支持快速查询 `子树`（Sub-tree）和 `溯源`（Ancestors）。
* **关联管理**：部门与用户、部门与负责人的关联。
* **数据权限支撑**：提供“本部门及子部门”的数据范围判定基础。

---

## 2. 数据模型设计 (Schema Proposal)

建议表名：`sys_organization` 或 `sys_department`

| 字段名 | 类型 | 必填 | 默认 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| `id` | bigint/string | Y | | 主键 (建议 Snowflake ID) |
| `parent_id` | bigint/string | Y | 0 | 父部门 ID，根节点为 0 或 null |
| `name` | varchar(100) | Y | | 部门名称 |
| `code` | varchar(50) | N | | 部门编码 (用于同步或业务标识) |
| `ancestors` | varchar(500) | Y | '' | **关键字段**：祖籍列表/层级路径。例 `0,101,105`，用于快速查询子树 |
| `sort_order` | int | N | 0 | 同级排序权重 |
| `leader_id` | bigint/string | N | | 部门负责人 ID (关联 User 表) |
| `type` | int/enum | Y | 1 | 节点类型：1=公司/租户级别的根, 2=部门/科室 |
| `status` | int/enum | Y | 1 | 状态：1=启用, 0=停用 |
| `description` | varchar(255) | N | | 备注 |
| `created_at` | datetime | Y | now | |
| `updated_at` | datetime | Y | now | |

> **设计说明 - `ancestors` 字段**：
> 采用 **Materialized Path (物化路径)** 模式。
> *   优势：查询某部门的所有子部门（无限级）非常快，SQL 仅需 `WHERE ancestors LIKE '%,{current_id},%'`。
> *   代价：移动部门（修改 `parent_id`）时，需要递归更新其所有子孙节点的 `ancestors` 字段。鉴于组织架构调整频率低，查询频率高，此方案最优。

---

## 3. 接口定义 (API Specification)

Prefix: `/api/system/organizations`

### 3.1 获取组织架构树
*   **Method**: `GET`
*   **Path**: `/tree`
*   **Query Params**:
    *   `name`: (Optional) 模糊搜索。若搜索，通常返回扁平列表或带路径的高亮树。
    *   `status`: (Optional) 过滤状态。
    *   `lazy`: `true/false` (是否懒加载，建议默认 false，一次性加载几千个节点通常前端能抗住，体验更好)。
*   **Response**: `Tree<OrganizationNode>[]`
    *   `OrganizationNode` 包含：`id`, `parentId`, `name`, `type`, `sortOrder`, `leaderName`, `children[]`.

### 3.2 组织详情
*   **Method**: `GET`
*   **Path**: `/{id}`
*   **Response**: 包含完整字段，以及 `parentName`（方便前端展示）。

### 3.3 新建组织
*   **Method**: `POST`
*   **Body**:
    *   `parentId`, `name`, `code`, `leaderId`, `sortOrder`, `type`, ...
*   **Logic**:
    *   校验 `parentId` 是否存在（除非是根节点）。
    *   计算 `ancestors`: `parent.ancestors + "," + parent.id`。
    *   校验同级名称唯一性 (Optional)。

### 3.4 更新组织
*   **Method**: `PUT`
*   **Path**: `/{id}`
*   **Body**: `name`, `leaderId`, `status`, `code`, `sortOrder`... (通常不在此接口修改 parentId)
*   **Logic**:
    *   若停用部门，需校验是否包含 **启用状态的子部门** 或 **关联的启用用户**，通常建议阻止或递归停用（慎用递归）。

### 3.5 删除组织
*   **Method**: `DELETE`
*   **Path**: `/{id}`
*   **Logic**:
    *   **强校验**：如果该组织下有 **子节点**，禁止删除 `(HasChildren Check)`。
    *   **强校验**：如果该组织下有 **关联用户**，禁止删除 `(HasUsers Check)`。
    *   逻辑删除 vs 物理删除：建议逻辑删除。

### 3.6 组织 移动/拖拽 (Reorder & Move)
*   **Method**: `POST` / `PUT`
*   **Path**: `/move` 或 `/{id}/parent`
*   **Body**:
    *   `targetParentId`: 新父节点。
    *   `siblings`: (Optional) 排序ID列表，用于拖拽后的排序。
*   **Core Logic (复杂点)**:
    1.  **环路检测**：`targetParentId` 不能是 `id` 本身或其子孙节点。
        *   Check: `SELECT count(1) FROM sys_org WHERE id = {targetParentId} AND ancestors LIKE '%,{id},%'`。若大于0，则报错“不能移动到自己的子节点下”。
    2.  **更新 Ancestors**：
        *   获取新父节点的 `new_ancestors`。
        *   更新本节点：`ancestors` = `new_ancestors` + `,` + `targetParentId`。
        *   **Cascade Update**：查找所有以本节点为祖先的子节点，替换其 `ancestors` 前缀。

### 3.7 获取部门下的用户 (Member List)
*   **Method**: `GET`
*   **Path**: `/{id}/users`
*   **Query**: `recursive=true/false` (是否查子部门用户)
*   **Logic**:
    *   如果 `recursive=true`: Join User表, `WHERE user.dept_id IN (SELECT id FROM org WHERE ancestors LIKE '%,{id},%' OR id = {id})`。

---

## 4. 业务规则与约束

1.  **根节点保护**：系统应初始化一个 Root 节点（如“集团总部”），通常不允许删除，只能修改名称。
2.  **停用逻辑**：
    *   部门停用后，该部门在“用户管理-部门选择”、“角色-数据范围选择”中应不可见或置灰。
    *   已在该部门的用户暂不受影响，但可能无法基于该部门进行新的业务操作。
3.  **负责人策略**：
    *   `leader_id` 仅做记录和简单的“消息通知”用途。
    *   若用于审批流（如“部门经理审批”），建议在 Workflow 引擎中通过 `GetDepartmentLeader(userId)` 动态获取。

---

## 5. 数据权限集成 (Data Scope Integration)

后端在处理业务数据的查询（如“查询销售订单”）时，需要解析用户的 Role Data Scope。
若 Role 配置为 `DATA_SCOPE_DEPT_AND_CHILD`（本部门及以下），则 SQL 拼接逻辑如下：

```sql
-- 伪代码
SELECT * FROM business_table 
WHERE create_by_dept_id IN (
    SELECT id FROM sys_organization 
    WHERE id = {currentUser.deptId} 
       OR ancestors LIKE CONCAT('%,', {currentUser.deptId}, ',%')
)
```

**性能优化建议**：
*   用户登录时，可将其 `deptId` 及所有 `subDeptIds` 缓存到 Redis Set 中。
*   鉴权时直接从 Redis 取出 ID 列表，使用 `WHERE dept_id IN (...)`，避免每次查询都 Join 组织表。

---

## 6. 扩展性预留

*   **多租户 (Multi-Tenant)**：若系统是 SaaS，所有 SQL 需追加 `tenant_id` 过滤。`ancestors` 仅在租户内有效。
*   **辅助岗位/多部门 (Check)**：当前模型假设一个用户属于一个主部门 (`user.dept_id`)。若需支持一人多部门，需引入 `sys_user_dept` 关联表，逻辑会复杂化（数据权限需取并集）。建议一期仅支持单主部门。
