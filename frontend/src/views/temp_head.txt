import { useState, useEffect } from 'react';
import {
    Plus, Play, Pause, RefreshCw, Clock, Database, Calendar,
    CheckCircle, XCircle, AlertCircle, Activity, List,
    Settings, ChevronDown, MoreHorizontal, X,
    Eye, Trash2, Zap, Layers, User, Target
} from 'lucide-react';
import {
    scanService,
    type ScanTask,
    type ScheduledScan,
    type ScheduledScanExecutionHistory,
    type TableScan,
    type TableInfo,
    type FieldInfo,
    ScanTaskType,
    ScanStrategy,
} from '../services/scanService';
import { dataSourceService, type DataSource } from '../services/dataSourceService';

const AssetScanningView = ({ onNavigate }: { onNavigate?: (moduleId: string) => void } = {}) => {
    // Tab 切换
    const [activeTab, setActiveTab] = useState<'instant' | 'scheduled' | 'history'>('instant');

    // 即时扫描任务
    const [instantTasks, setInstantTasks] = useState<ScanTask[]>([]);
    const [instantLoading, setInstantLoading] = useState(false);

    // 定时扫描任务
    const [scheduledTasks, setScheduledTasks] = useState<ScheduledScan[]>([]);
    const [scheduledLoading, setScheduledLoading] = useState(false);

    // 数据源列表
    const [dataSources, setDataSources] = useState<DataSource[]>([]);

    // 弹窗状态
    const [showCreateModal, setShowCreateModal] = useState(false);
    const [showDetailModal, setShowDetailModal] = useState(false);
    const [showScheduledDetailModal, setShowScheduledDetailModal] = useState(false);
    const [showExecutionHistoryModal, setShowExecutionHistoryModal] = useState(false);

    // 当前选中的任务
    const [selectedTask, setSelectedTask] = useState<ScanTask | null>(null);
    const [selectedScheduledTask, setSelectedScheduledTask] = useState<ScheduledScan | null>(null);
    // 编辑中的定时任务（用于弹窗表单）
    const [editingScheduledTask, setEditingScheduledTask] = useState<ScheduledScan | null>(null);

    // 表扫描信息
    const [tableScans, setTableScans] = useState<TableScan[]>([]);
    const [tableScansLoading, setTableScansLoading] = useState(false);

    // 执行历史
    const [executionHistory, setExecutionHistory] = useState<ScheduledScanExecutionHistory[]>([]);

    // 新建任务表单
    const [newTask, setNewTask] = useState({
        scanName: '',
        type: ScanTaskType.DataSourceInstant,
        dataSourceId: '',
        dataSourceType: 'MySQL',
        scanStrategy: [] as ('insert' | 'update' | 'delete')[],
        selectedTables: [] as string[],
        cronExpression: '0 0 2 * * ?',
        status: 'open' as 'open' | 'close',
    });

    // 表选择相关
    const [availableTables, setAvailableTables] = useState<TableInfo[]>([]);
    const [tablesLoading, setTablesLoading] = useState(false);
    const [tableSearchKeyword, setTableSearchKeyword] = useState('');

    // 保存每个任务的扫描策略（因为后端API不返回这个字段）
    const [taskScanStrategies, setTaskScanStrategies] = useState<Record<string, ('insert' | 'update' | 'delete')[]>>({});
    // 保存每个任务的状态（因为后端API可能不立即返回更新的状态）
    const [taskStatuses, setTaskStatuses] = useState<Record<string, 'enable' | 'disable'>>({});

    // 字段信息相关
    const [showFieldModal, setShowFieldModal] = useState(false);
    const [selectedTableForFields, setSelectedTableForFields] = useState<TableScan | null>(null);
    const [tableFields, setTableFields] = useState<FieldInfo[]>([]);
    const [fieldsLoading, setFieldsLoading] = useState(false);

    // 加载数据源
    useEffect(() => {
        loadDataSources();
    }, []);

    // 加载即时扫描任务
    useEffect(() => {
        if (activeTab === 'instant') {
            loadInstantTasks();
        }
    }, [activeTab]);

    // 加载定时扫描任务
    useEffect(() => {
        if (activeTab === 'scheduled') {
            loadScheduledTasks();
        }
    }, [activeTab]);

    const loadDataSources = async () => {
        try {
            const result = await dataSourceService.getDataSources();
            setDataSources(result);
        } catch (error) {
            console.error('Failed to load data sources:', error);
        }
    };

    const loadInstantTasks = async () => {
        setInstantLoading(true);
        try {
            const tasks = await scanService.getScanTasks();
            // 过滤出即时扫描任务（没有 schedule_id 的）
            const instant = tasks.filter(t => !t.isScheduled);
            setInstantTasks(instant);
        } catch (error) {
            console.error('Failed to load instant scan tasks:', error);
        } finally {
            setInstantLoading(false);
        }
    };

    const loadScheduledTasks = async () => {
        setScheduledLoading(true);
        try {
            const tasks = await scanService.getScanTasks();
            // 过滤出定时扫描任务（有 schedule_id 的）
            const scheduled = tasks.filter(t => t.isScheduled);
            // 合并保存的扫描策略和状态
            const scheduledWithCache = scheduled.map(task => {
                const scheduleId = task.scheduleId || '';
                return {
                    ...task,
                    scanStrategy: taskScanStrategies[scheduleId] || task.scanStrategy || [],
                    taskStatus: taskStatuses[scheduleId] || task.taskStatus,
                };
            });
            setScheduledTasks(scheduledWithCache);
        } catch (error) {
            console.error('Failed to load scheduled scan tasks:', error);
        } finally {
            setScheduledLoading(false);
        }
    };

    const handleCreateTask = async () => {
        if (!newTask.scanName || !newTask.dataSourceId) {
            alert('请填写必填项');
            return;
        }

        // 表即时扫描需要选择表
        if (newTask.type === ScanTaskType.TableInstant && newTask.selectedTables.length === 0) {
            alert('请至少选择一个表');
            return;
        }

        try {
            const ds = dataSources.find(d => d.id === newTask.dataSourceId);
            if (!ds) return;

            await scanService.createScanTask({
                scanName: newTask.scanName,
                type: newTask.type,
                dataSourceId: newTask.dataSourceId,
                dataSourceType: newTask.dataSourceType,
                scanStrategy: newTask.scanStrategy.length > 0 ? newTask.scanStrategy : undefined,
                tables: newTask.selectedTables.length > 0 ? newTask.selectedTables : undefined,
                cronExpression: newTask.type === ScanTaskType.DataSourceScheduled ? newTask.cronExpression : undefined,
                status: newTask.status,
            });

            setShowCreateModal(false);
            resetNewTask();

            if (activeTab === 'instant') {
                loadInstantTasks();
            } else {
                loadScheduledTasks();
            }
        } catch (error) {
            console.error('Failed to create scan task:', error);
            alert('创建扫描任务失败：' + (error as Error).message);
        }
    };

    const resetNewTask = () => {
        setNewTask({
            scanName: '',
            type: ScanTaskType.DataSourceInstant,
            dataSourceId: '',
            dataSourceType: 'MySQL',
            scanStrategy: [] as ('insert' | 'update' | 'delete')[],
            selectedTables: [],
            cronExpression: '0 0 2 * * ?',
            status: 'open',
        });
        setAvailableTables([]);
        setTableSearchKeyword('');
    };

    // 加载数据源下的表列表
    const loadTablesForDataSource = async (dataSourceId: string, dataSourceType?: string) => {
        if (!dataSourceId) {
            setAvailableTables([]);
            return;
        }

        setTablesLoading(true);
        try {
            const result = await scanService.getTablesByDataSourceId({
                dataSourceId,
                limit: 100,
            });
            // 为每个表设置数据源类型（从参数获取，如果没有则使用 newTask 中的值）
            const dbType = dataSourceType || newTask.dataSourceType;
            const tablesWithDbType = result.tables.map(table => ({
                ...table,
                dbType: dbType || table.dbType,
            }));
            setAvailableTables(tablesWithDbType);
        } catch (error) {
            console.error('Failed to load tables:', error);
            setAvailableTables([]);
        } finally {
            setTablesLoading(false);
        }
    };

    // 查看表字段信息
    const handleViewTableFields = async (table: TableScan) => {
        setSelectedTableForFields(table);
        setShowFieldModal(true);
        setFieldsLoading(true);

        try {
            const result = await scanService.getFieldsByTableId({
                tableId: table.tableId,
                limit: 500,
            });
            setTableFields(result.fields);
        } catch (error) {
            console.error('Failed to load table fields:', error);
            setTableFields([]);
        } finally {
            setFieldsLoading(false);
        }
    };

    const handleViewDetail = async (task: ScanTask) => {
        setSelectedTask(task);
        setShowDetailModal(true);
        setTableScansLoading(true);

        try {
            const result = await scanService.getTableScanInfo({ taskId: task.id });
            setTableScans(result.tables);
        } catch (error) {
            console.error('Failed to load table scan info:', error);
        } finally {
            setTableScansLoading(false);
        }
    };

    const handleViewScheduledDetail = async (task: ScanTask) => {
        if (!task.scheduleId) return;

        try {
            // 优先使用任务列表中的 scanStrategy（用户之前保存的）
            // 只有在缺少必要信息时才从后端 API 获取
            let cronExpression = task.scanStrategy && task.scanStrategy.length > 0 ? undefined : '0 0 2 * * ?';
            let nextRunTime: string | undefined = undefined;
            let createTime: string | undefined = undefined;

            try {
                // 尝试从后端获取 cron 表达式和执行时间信息
                const statusResult: any = await scanService.getScheduledScanStatus(task.scheduleId, '2');
                cronExpression = statusResult.cronExpression;
                nextRunTime = statusResult.nextRunTime;
                createTime = statusResult.createTime;
            } catch (apiError) {
                // 如果 API 调用失败，使用默认值
                console.warn('Failed to fetch scheduled task status from API, using task list data:', apiError);
            }

            // 使用任务列表中的数据作为主要来源，特别是 scanStrategy
            const mergedTask: ScheduledScan = {
                scheduleId: task.scheduleId,
                name: task.name,
                dataSourceType: task.dataSourceType,
                // 优先使用任务列表中的 scanStrategy（用户之前保存的）
                scanStrategy: task.scanStrategy || [],
                cronExpression: cronExpression || '0 0 2 * * ?',
                status: task.taskStatus === 'enable' ? 'open' : 'close',
                createTime: createTime || task.startTime,
                nextRunTime: nextRunTime,
            };

            setSelectedScheduledTask(mergedTask);
            // 初始化编辑状态为当前值的副本
            setEditingScheduledTask({ ...mergedTask });
            setShowScheduledDetailModal(true);
        } catch (error) {
            console.error('Failed to load scheduled task details:', error);
            // 即使出错也使用任务列表中的数据打开弹窗
            const fallbackTask: ScheduledScan = {
                scheduleId: task.scheduleId,
                name: task.name,
                dataSourceType: task.dataSourceType,
                scanStrategy: task.scanStrategy || [],
                cronExpression: '0 0 2 * * ?',
                status: task.taskStatus === 'enable' ? 'open' : 'close',
                createTime: task.startTime,
                nextRunTime: undefined,
            };
            setSelectedScheduledTask(fallbackTask);
            setEditingScheduledTask({ ...fallbackTask });
            setShowScheduledDetailModal(true);
        }
    };

    const handleViewExecutionHistory = async (task: ScanTask) => {
        setSelectedTask(task);
        setShowExecutionHistoryModal(true);

        if (!task.scheduleId) return;

        try {
            // 使用正确的接口：getScheduledScanTaskList 对应后端的 /scan/schedule/task/{scheduleId}
            const result = await scanService.getScheduledScanTaskList(task.scheduleId);
            setExecutionHistory(result.executions);
        } catch (error) {
            console.error('Failed to load execution history:', error);
        }
    };

    const handleExecuteTask = async (task: ScanTask) => {
        if (!task.scheduleId) return;

        try {
            await scanService.executeScheduledScan(task.scheduleId);
            alert('任务已提交执行');
            loadScheduledTasks();
        } catch (error) {
            console.error('Failed to execute task:', error);
            alert('立即执行失败：' + (error as Error).message);
        }
    };

    const handleDeleteTask = async (task: ScanTask) => {
        if (!task.scheduleId) return;

        if (!confirm(`确定要删除定时任务"${task.name}"吗？此操作不可恢复。`)) {
            return;
        }

        try {
            await scanService.deleteScheduledScan(task.scheduleId);
            alert('删除成功');
            loadScheduledTasks();
        } catch (error) {
            console.error('Failed to delete task:', error);
            alert('删除失败：' + (error as Error).message);
        }
    };

    const handleSaveScheduledTask = async () => {
        if (!editingScheduledTask) return;

        try {
            await scanService.updateScheduledScan({
                scheduleId: editingScheduledTask.scheduleId,
                cronExpression: editingScheduledTask.cronExpression,
                scanStrategy: editingScheduledTask.scanStrategy,
                status: editingScheduledTask.status,
            });

            // 保存扫描策略到本地状态（因为后端API不返回这个字段）
            setTaskScanStrategies(prev => ({
                ...prev,
                [editingScheduledTask.scheduleId]: editingScheduledTask.scanStrategy || [],
            }));

            // 更新本地状态：在 scheduledTasks 中找到对应的任务并更新其 scanStrategy
            setScheduledTasks(prevTasks =>
                prevTasks.map(task =>
                    task.scheduleId === editingScheduledTask.scheduleId
                        ? { ...task, scanStrategy: editingScheduledTask.scanStrategy }
                        : task
                )
            });

            // 更新成功后刷新列表并关闭弹窗
            alert('保存成功');
            setShowScheduledDetailModal(false);
            // 同时也刷新列表，确保数据一致
            loadScheduledTasks();
        } catch (error) {
            console.error('Failed to update scheduled task:', error);
            alert('保存失败：' + (error as Error).message);
        }
    };
